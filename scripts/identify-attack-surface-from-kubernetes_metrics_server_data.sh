#!/bin/bash
##############################################################################
# Script to identify, the K8S items accessible by the current service token 
# based on information leaked from an instance of Kubernetes Metrics Server
# via its endpoints "/metrics".
#
# References used:
#	https://github.com/kubernetes-sigs/metrics-server
#	https://kubernetes.io/docs/reference/kubectl/
#	https://kubernetes.io/docs/tasks/run-application/access-api-from-pod/
#
# Requirements in terms of software:
# 	apt install curl jq xxd
#	https://kubernetes.io/docs/reference/kubectl/
#
# Notes & conventions: 
#   K8S === KUBERNETES
#	KMS === KUBERNETES METRICS SERVER
##############################################################################

# Constants
WORK="/tmp/work.tmp"
LOG="/tmp/work.log"

# Utility functions
function write_step(){
	echo -e "\e[93m[*] $1\e[0m"
}

function write_sub_step(){
	echo -e "\e[36m[>] $1\e[0m"
}

function write_step_failure(){
	echo -e "\e[91m[!] $1\e[0m"
}

# Processing functions
function run_cmd(){
	cmd="$1"
	echo "$cmd" >> $LOG
	eval "$cmd" 1>$WORK 2>&1
	is_forbidden=$(grep -Fic "(Forbidden)" $WORK)
	if [ $is_forbidden -eq 0 ]
	then
		write_sub_step "Seemed allowed => '$cmd'."
	fi
}

function test_access(){
	record=$(echo $1 | xxd -r -p)
	is_comment=$(echo "$record" | grep -Ec "^#.*")
	if [ $is_comment -eq 0 ]
	then
		namespace=$(echo "$record)" | grep -Po 'namespace=".*?"' | cut -d'=' -f2 | tr -d '"')
		pod=$(echo "$record)" | grep -Po 'pod=".*?"' | cut -d'=' -f2 | tr -d '"')
		service=$(echo "$record)" | grep -Po 'service=".*?"' | cut -d'=' -f2 | tr -d '"')
		deployment=$(echo "$record)" | grep -Po 'deployment=".*?"' | cut -d'=' -f2 | tr -d '"')
		secret=$(echo "$record)" | grep -Po 'secret=".*?"' | cut -d'=' -f2 | tr -d '"')		
		configmap=$(echo "$record)" | grep -Po 'configmap=".*?"' | cut -d'=' -f2 | tr -d '"')
		check_not_yet_supported=0
		if [ "$pod" != "" ]
		then
			cmd="describe pod $pod"
		elif [ "$service" != "" ]
		then
			cmd="describe service $service"
		elif [ "$deployment" != "" ]
		then
			cmd="describe deployment $deployment"
		elif [ "$secret" != "" ]
		then
			cmd="describe secret $secret"
		elif [ "$configmap" != "" ]
		then
			cmd="describe configmap $configmap"
		else
			check_not_yet_supported=1
		fi
		if [ $check_not_yet_supported -eq 0 ]
		then
			if [ "$namespace" != "" ]
			then
				cmd="$cmd -n $namespace"
			fi
			final_cmd="kubectl $cmd"	
			# Test for current item 
			run_cmd "$final_cmd"
			# Test to get all resources in the current namespace
			# here I accept to run duplicate commands
			if [ "$namespace" != "" ]
			then
				run_cmd "kubectl get all,cm,secret,ing -n $namespace"
			fi			
		fi
	fi
}
# Entry point & Main processing
if [ "$#" -lt 1 ]; then
	script_name=$(basename "$0")
	echo "Usage:"
	echo "   $script_name [KMS_DATA_TEXT_FILE]"
	echo ""
	echo "Call example:"
	echo "    $script_name data.txt"
    exit 1
fi
rm $LOG 2>/dev/null
write_step "Check presence of 'kubectl'..."
kubectl version 1>/dev/null 2>&1
if [ $? -ne 0 ]
then
	write_step_failure "kubectl not found."
	exit 2
else
	kubectl version
fi
write_step "Check access to K8S items present into the KMS file..."
kms_file=$1
while read -r line; do
    record=$(echo "$line" | xxd -p)
    test_access "$record"
done < $kms_file
write_step "Commands tested:"
wc -l $LOG
rm $WORK