#!/usr/bin/env python
import re
import argparse
from termcolor import colored
from pathlib import Path
from tqdm import tqdm

"""
When I perform a web app assessment and I have access to the source code, I want to ensure that
I do not miss any API endpoints. So, this script allow me to made a diff between the list of API endpoints
I seens during the assessment against the list of API endpoints really exposed by the app based on the source code.

This script to extract all endpoints paths, from a codebase, using dedicated marker like, for example, the @Path annotation.

References:
    https://docs.oracle.com/cd/E19798-01/821-1841/6nmq2cp26/index.html

Dependencies:
    pip3 install tqdm termcolor
"""

EXTENSION_OF_FILE_PROCESSED = [".java"]
ENCODINGS_SEQUENCE = ["utf-8", "latin"]


def load_code(source_file):
    code = ""
    for enc in ENCODINGS_SEQUENCE:
        try:
            with source_file.open(mode="r", encoding=enc) as f:
                code = f.read()
            if len(code) > 0:
                break
        except UnicodeDecodeError:
            code = ""
            pass
    if len(code) == 0:
        raise Exception(f"Cannot load the code from the file {source_file} !")
    return code


def process_code_using_path_annotation(source_code):
    endpoints = []
    marker = "@Path("
    regex = r'@Path\(["\']([a-z0-9_{}\/\-]*)["\']\)'
    lines_of_code = source_code.split("\n")
    base_edp_path = ""
    class_or_interface_declaration_seen = False
    for line_of_code in lines_of_code:
        if " class " in line_of_code or " interface " in line_of_code:
            class_or_interface_declaration_seen = True
        if marker in line_of_code:
            if not class_or_interface_declaration_seen:
                base_edp_path = re.findall(regex, line_of_code, re.IGNORECASE)[0]
            else:
                edp_path = re.findall(regex, line_of_code, re.IGNORECASE)[0]
                endpoints.append(f"{base_edp_path}{edp_path}")
    return endpoints


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Script to extract all endpoints paths, from a codebase, using dedicated markers.")
    parser.add_argument("-b", action="store", dest="base_folder", help="Base folder containing the source code to process", required=True)
    args = parser.parse_args()
    base_folder = args.base_folder
    print(colored(f"[+] Processing files...", "yellow"))
    global_endpoints = []
    content = list(Path(base_folder).rglob("*.*"))
    source_files = [f for f in content if f.is_file()]
    for i in tqdm(range(len(source_files))):
        source_file = source_files[i]
        if (source_file.suffix in EXTENSION_OF_FILE_PROCESSED):
            source_code = load_code(source_file)
            endpoints = process_code_using_path_annotation(source_code)
            if len(endpoints) > 0:
                global_endpoints.extend(endpoints)
    print(colored(f"[+] Endpoints identified:", "yellow"))
    final_endpoints_list = list(set(global_endpoints))
    final_endpoints_list.sort()
    print("\n".join(final_endpoints_list))
