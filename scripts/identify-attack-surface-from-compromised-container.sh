#!/bin/bash
####################################################################
# Script to identify, the possible attack surface, when we are 
# in a compromised container deployed in a Kubernetes cluster
#
# References used:
#	https://github.com/righettod/toolbox-pentest-web/issues/44
#   https://kubernetes.io/docs/tasks/run-application/access-api-from-pod/
#   https://kubernetes.io/docs/concepts/configuration/secret/
#   https://github.com/righettod/toolbox-pentest-web/blob/master/docs/0_METHODOLOGIES.md#methodology-for-assumed-container-breach-assessment
#
# Requirements in terms of software:
# 	apt install curl jq nmap
#
# Note: K8S === KUBERNETES
####################################################################

# Constants
KUBERNETES_SECRETS_PATH="/var/run/secrets/kubernetes.io"
KUBERNETES_SERVICE_ACCOUNT_TOKEN_FILE="$KUBERNETES_SECRETS_PATH/serviceaccount/token"
KUBERNETES_INTERESTING_API_LIST=("api/v1/namespaces/default/pods" "api/v1/namespaces/default/secrets")

# Utility functions
function write_step(){
	echo -e "\e[93m[*] $1\e[0m"
}

function write_sub_step(){
	echo -e "\e[36m[>] $1\e[0m"
}

function write_step_failure(){
	echo -e "\e[91m[!] $1\e[0m"
}

# Processing functions
function check_vector_current_container_k8s_secrets(){
    write_step "Current container: Kubernetes secrets"
    rc=1
    if [ -d "$KUBERNETES_SECRETS_PATH" ]; then
        find "$KUBERNETES_SECRETS_PATH" -type f
        rc=0
    else
        write_step_failure "Kubernetes secrets folder not found."
    fi
    return $rc
}

function check_vector_current_container_k8s_env(){
    write_step "Current container: Kubernetes environment"
    rc=1
    env_count=$(env | grep -Fc "KUBERNETES")
    if [ $env_count -ne 0 ]; then
        env | grep -F "KUBERNETES"
        rc=0
    else
        write_step_failure "Kubernetes environment variables not found."
    fi
    return $rc
}

function check_vector_k8s_api(){
    write_step "Kubernetes API access rights using service account token"
    rc=1
    if [ -f "$KUBERNETES_SERVICE_ACCOUNT_TOKEN_FILE" ]; then
        token=$(cat $KUBERNETES_SERVICE_ACCOUNT_TOKEN_FILE)
        for api_path in "${KUBERNETES_INTERESTING_API_LIST[@]}"
        do
            write_sub_step "Endpoint: $api_path"
            curl -ks -H "Authorization: Bearer $token" "https://$KUBERNETES_SERVICE_HOST:$KUBERNETES_SERVICE_PORT_HTTPS/$api_path"
            echo " "
        done
        rc=0        
    else
        write_step_failure "Kubernetes service account token file not found."
    fi
    return $rc
}

# Entry point & Main processing
container_ip=$(ip addr show eth0 | grep "inet\b" | awk '{print $2}' | cut -d/ -f1)
container_ip_range=$(echo $container_ip | awk -F'.' '{print $1"."$2"."$3".0/24" }')
check_vector_current_container_k8s_secrets
check_vector_current_container_k8s_env
check_vector_k8s_api