#!/bin/bash
####################################################################
# Script to identify, the possible attack surface, when we are 
# in a compromised container deployed in a Kubernetes cluster
#
# References used:
#	https://github.com/righettod/toolbox-pentest-web/issues/44
#	https://kubernetes.io/docs/tasks/run-application/access-api-from-pod/
#	https://kubernetes.io/docs/concepts/configuration/secret/
#	https://github.com/righettod/toolbox-pentest-web/blob/master/docs/0_METHODOLOGIES.md#methodology-for-assumed-container-breach-assessment
#	https://docs.openshift.com/container-platform/4.16/rest_api/
#	https://developer.hashicorp.com/vault/docs/platform/k8s
#	https://developer.hashicorp.com/vault/api-docs
#	https://developer.hashicorp.com/vault/docs/secrets/kv
#	https://developer.hashicorp.com/vault/api-docs/system
#   https://unofficial-kubernetes.readthedocs.io/en/latest/concepts/policy/container-capabilities/
#   https://man7.org/linux/man-pages/man7/capabilities.7.html
#
# Requirements in terms of software:
# 	apt install curl libcap-ng libcap-ng-utils
#
# Notes & conventions: 
#   K8S   === KUBERNETES
#   VAULT === HASHICORP VAULT
####################################################################

# Constants
NET_INTERFACE_NAME="eth0"
APP_COMMON_SECRETS_PATHS=("/etc/secrets" "/var/secrets")
KUBERNETES_SITE_BASE="https://cdn.dl.k8s.io"
KUBERNETES_SECRETS_PATH="/var/run/secrets/kubernetes.io"
KUBERNETES_SERVICE_ACCOUNT_TOKEN_FILE="$KUBERNETES_SECRETS_PATH/serviceaccount/token"
KUBERNETES_CURRENT_NAMESPACE_NAME_FILE="$KUBERNETES_SECRETS_PATH/serviceaccount/namespace"
KUBERNETES_INTERESTING_NS_SCOPED_API_LIST=("api/v1/namespaces/default/pods" "api/v1/namespaces/default/secrets" "api/v1/namespaces/default/configmaps" "api/v1/namespaces/default/endpoints" "api/v1/namespaces/default/services" "api/v1/namespaces/default/serviceaccounts")
KUBERNETES_INTERESTING_NOTNS_API_LIST=("api/v1/namespaces" "api/v1/nodes" "api/v1/persistentvolumes" "api/v1/pods" "api/v1/secrets")
VAULT_INTERESTING_API_LIST=("v1/sys/health" "v1/sys/host-info" "v1/sys/license/status" "v1/sys/auth" "v1/sys/config/state/sanitized" "v1/secret?list=true" "v1/secret/metadata?list=true")

# Utility functions
function write_step(){
	echo -e "\e[93m[*] $1\e[0m"
}

function write_sub_step(){
	echo -e "\e[36m[>] $1\e[0m"
}

function write_step_failure(){
	echo -e "\e[91m[!] $1\e[0m"
}

# Processing functions
function test_k8s_api_access(){
    token=$1
    api_path=$2
    endpoint_type=$3
    endpoint="https://$KUBERNETES_SERVICE_HOST:$KUBERNETES_SERVICE_PORT_HTTPS/$api_path"    
    http_code=$(curl -ks -o /dev/null -w "%{http_code}" -H "Authorization: Bearer $token" "$endpoint")
    echo "($http_code) $endpoint_type: $api_path"
}


function check_vector_current_container_k8s_env(){
    write_step "Current container: Kubernetes environment"
    rc=1
    env_count=$(env | grep -Fc "KUBERNETES")
    if [ $env_count -ne 0 ]; then
        env | grep -F "KUBERNETES"
        rc=0
    else
        write_step_failure "Kubernetes environment variables not found."
    fi
    return $rc
}


function check_vector_current_container_app_env(){
    write_step "Current container: App environment"
    expr="(SECRET|PASSWORD|PASS|PW|TOKEN|KEY|SALT)"
    rc=1
    env_count=$(env | grep -Eic "$expr")
    if [ $env_count -ne 0 ]; then
        env | grep -Ei "$expr"
        rc=0
    else
        write_step_failure "App environment variables related to secrets not found."
    fi
    return $rc
}


function check_vector_current_container_k8s_secrets(){
    write_step "Current container: Kubernetes secrets"
    rc=1
    if [ -d "$KUBERNETES_SECRETS_PATH" ]; then
        find "$KUBERNETES_SECRETS_PATH" -type f
        rc=0
    else
        write_step_failure "Kubernetes secrets folder not found."
    fi
    return $rc
}


function check_vector_current_container_app_secrets(){
    write_step "Current container: App secrets"
    rc=1
    for path in "${APP_COMMON_SECRETS_PATHS[@]}"
    do
        if [ -d "$path" ]; then
            file_count=$(find "$path" -type f | wc -l)
            if [ $file_count -ne 0 ]; then
                find "$path" -type f
                rc=0
            fi
        fi    
    done
    if [ $rc -ne 0 ]; then    
        write_step_failure "App common secrets folder not found or empty."
    fi
    return $rc
}


function check_vector_k8s_api(){
    write_step "Kubernetes API access rights using service account token"
    rc=1
    if [ -f "$KUBERNETES_SERVICE_ACCOUNT_TOKEN_FILE" ]; then
        token=$(cat $KUBERNETES_SERVICE_ACCOUNT_TOKEN_FILE)
        current_namespace=$(cat $KUBERNETES_CURRENT_NAMESPACE_NAME_FILE)
        for api_path in "${KUBERNETES_INTERESTING_NOTNS_API_LIST[@]}"
        do
            test_k8s_api_access "$token" "$api_path" "General endpoint"
        done        
        for api_path in "${KUBERNETES_INTERESTING_NS_SCOPED_API_LIST[@]}"
        do
            test_k8s_api_access "$token" "$api_path" "Default namespace endpoint"
        done
        for api_path in "${KUBERNETES_INTERESTING_NS_SCOPED_API_LIST[@]}"
        do
            api_path_current_ns=$(echo "$api_path" | sed "s/default/$current_namespace/g")
            test_k8s_api_access "$token" "$api_path_current_ns" "Current namespace endpoint"
        done        
        rc=0        
    else
        write_step_failure "Kubernetes service account token file not found."
    fi
    return $rc
}


function check_vector_vault_api(){
    write_step "Vault API access rights using vault token"
    token="$VAULT_TOKEN"
    rc=1
    if [ "$token" != "" ]; then
        for api_path in "${VAULT_INTERESTING_API_LIST[@]}"
        do
            write_sub_step "Endpoint: $api_path"
            curl -ks -H "X-Vault-Token: $token" -H "X-Vault-Request: true" "$VAULT_ADDR/$api_path"
            echo " "        
        done
        rc=0
    else
        write_step_failure "Vault token not found."    
    fi
    return $rc
}


function check_vector_network(){
    container_ip=$(ip addr show $NET_INTERFACE_NAME | grep "inet\b" | awk '{print $2}' | cut -d/ -f1)
    container_cidr=$(ip addr show $NET_INTERFACE_NAME | grep "inet\b" | awk '{print $2}' | cut -d/ -f2)
    container_ip_range=$(echo $container_ip | awk -F'.' '{print $1"."$2"."$3".0" }')
    container_ip_range="$container_ip_range/$container_cidr"
    write_step "Current container: Network"
    echo "IP address: $container_ip"
    echo "CIDR      : $container_ip_range"
}

function check_vector_current_container_capabilities(){
    write_step "Current container: Capabilities"
    rc=1    
    which pscap 1> /dev/null 2>&1
    if [ $? -eq 0 ]; then
        pscap -a
        rc=0
    else
        write_step_failure "Binary 'pscap' not found."     
    fi
    return $rc
}

function check_vector_current_container_internet_access(){
    write_step "Current container: Internet access"
    kubectl_version=$(curl --connect-timeout 10 --max-time 10 -sk $KUBERNETES_SITE_BASE/release/stable.txt)    
    can_access_k8s_site=$(echo "$kubectl_version" | grep -Ec "v[0-9.]+")
    if [ $can_access_k8s_site -eq 1 ]; then
        echo "Can access to the K8S site."
        echo "Use this URL to download the 'kubectl' binary: $KUBERNETES_SITE_BASE/release/$kubectl_version/bin/linux/amd64/kubectl"
    else
        write_step_failure "Cannot access to the K8S site."     
    fi
}


# Entry point & Main processing
check_vector_current_container_k8s_secrets
check_vector_current_container_app_secrets
check_vector_current_container_k8s_env
check_vector_current_container_app_env
check_vector_current_container_capabilities
check_vector_k8s_api
check_vector_vault_api
check_vector_network
check_vector_current_container_internet_access
