#!/bin/bash
####################################################################
# Script to identify, the possible attack surface, when we are 
# in a compromised container deployed in a Kubernetes cluster
#
# References used:
#	https://github.com/righettod/toolbox-pentest-web/issues/44
#	https://kubernetes.io/docs/tasks/run-application/access-api-from-pod/
#	https://kubernetes.io/docs/concepts/configuration/secret/
#	https://github.com/righettod/toolbox-pentest-web/blob/master/docs/0_METHODOLOGIES.md#methodology-for-assumed-container-breach-assessment
#	https://docs.openshift.com/container-platform/4.16/rest_api/
#	https://developer.hashicorp.com/vault/docs/platform/k8s
#	https://developer.hashicorp.com/vault/api-docs
#	https://developer.hashicorp.com/vault/docs/secrets/kv
#	https://developer.hashicorp.com/vault/api-docs/system
#
# Requirements in terms of software:
# 	apt install curl
#
# Notes & conventions: 
#   K8S   === KUBERNETES
#   VAULT === HASHICORP VAULT
####################################################################

# Constants
NET_INTERFACE_NAME="eth0"
KUBERNETES_SECRETS_PATH="/var/run/secrets/kubernetes.io"
KUBERNETES_SERVICE_ACCOUNT_TOKEN_FILE="$KUBERNETES_SECRETS_PATH/serviceaccount/token"
KUBERNETES_CURRENT_NAMESPACE_NAME_FILE="$KUBERNETES_SECRETS_PATH/serviceaccount/namespace"
KUBERNETES_INTERESTING_NS_SCOPED_API_LIST=("api/v1/namespaces/default/pods" "api/v1/namespaces/default/secrets" "api/v1/namespaces/default/configmaps" "api/v1/namespaces/default/endpoints" "api/v1/namespaces/default/services" "api/v1/namespaces/default/serviceaccounts")
KUBERNETES_INTERESTING_NOTNS_API_LIST=("api/v1/namespaces" "api/v1/nodes" "api/v1/persistentvolumes" "api/v1/pods" "api/v1/secrets")
VAULT_INTERESTING_API_LIST=("v1/sys/health" "v1/sys/host-info" "v1/sys/license/status" "v1/sys/auth" "v1/sys/config/state/sanitized" "v1/secret?list=true" "v1/secret/metadata?list=true")

# Utility functions
function write_step(){
	echo -e "\e[93m[*] $1\e[0m"
}

function write_sub_step(){
	echo -e "\e[36m[>] $1\e[0m"
}

function write_step_failure(){
	echo -e "\e[91m[!] $1\e[0m"
}

# Processing functions
function check_vector_current_container_app_env(){
    write_step "Current container: App environment"
    expr="(SECRET|PASSWORD|PASS|PW|TOKEN|KEY|SALT)"
    rc=1
    env_count=$(env | grep -Eic "$expr")
    if [ $env_count -ne 0 ]; then
        env | grep -Ei "$expr"
        rc=0
    else
        write_step_failure "App environment variables related to secrets not found."
    fi
    return $rc
}

function check_vector_current_container_k8s_secrets(){
    write_step "Current container: Kubernetes secrets"
    rc=1
    if [ -d "$KUBERNETES_SECRETS_PATH" ]; then
        find "$KUBERNETES_SECRETS_PATH" -type f
        rc=0
    else
        write_step_failure "Kubernetes secrets folder not found."
    fi
    return $rc
}

function check_vector_current_container_k8s_env(){
    write_step "Current container: Kubernetes environment"
    rc=1
    env_count=$(env | grep -Fc "KUBERNETES")
    if [ $env_count -ne 0 ]; then
        env | grep -F "KUBERNETES"
        rc=0
    else
        write_step_failure "Kubernetes environment variables not found."
    fi
    return $rc
}

function check_vector_k8s_api(){
    write_step "Kubernetes API access rights using service account token"
    rc=1
    if [ -f "$KUBERNETES_SERVICE_ACCOUNT_TOKEN_FILE" ]; then
        token=$(cat $KUBERNETES_SERVICE_ACCOUNT_TOKEN_FILE)
        current_namespace=$(cat $KUBERNETES_CURRENT_NAMESPACE_NAME_FILE)
        for api_path in "${KUBERNETES_INTERESTING_NOTNS_API_LIST[@]}"
        do
            write_sub_step "General endpoint: $api_path"
            curl -ks -H "Authorization: Bearer $token" "https://$KUBERNETES_SERVICE_HOST:$KUBERNETES_SERVICE_PORT_HTTPS/$api_path"
            echo " "
        done        
        for api_path in "${KUBERNETES_INTERESTING_NS_SCOPED_API_LIST[@]}"
        do
            write_sub_step "Default namespace endpoint: $api_path"
            curl -ks -H "Authorization: Bearer $token" "https://$KUBERNETES_SERVICE_HOST:$KUBERNETES_SERVICE_PORT_HTTPS/$api_path"
            echo " "
        done
        for api_path in "${KUBERNETES_INTERESTING_NS_SCOPED_API_LIST[@]}"
        do
            api_path_current_ns=$(echo "$api_path" | sed "s/default/$current_namespace/g")
            write_sub_step "Current namespace endpoint: $api_path_current_ns"
            curl -ks -H "Authorization: Bearer $token" "https://$KUBERNETES_SERVICE_HOST:$KUBERNETES_SERVICE_PORT_HTTPS/$api_path_current_ns"
            echo " "
        done        
        rc=0        
    else
        write_step_failure "Kubernetes service account token file not found."
    fi
    return $rc
}

function check_vector_vault_api(){
    write_step "Vault API access rights using vault token"
    token="$VAULT_TOKEN"
    rc=1
    if [ "$token" != "" ]; then
        for api_path in "${VAULT_INTERESTING_API_LIST[@]}"
        do
            write_sub_step "Endpoint: $api_path"
            curl -ks -H "X-Vault-Token: $token" -H "X-Vault-Request: true" "$VAULT_ADDR/$api_path"
            echo " "        
        done
        rc=0
    else
        write_step_failure "Vault token not found."    
    fi
}

function check_vector_network(){
    container_ip=$(ip addr show $NET_INTERFACE_NAME | grep "inet\b" | awk '{print $2}' | cut -d/ -f1)
    container_cidr=$(ip addr show $NET_INTERFACE_NAME | grep "inet\b" | awk '{print $2}' | cut -d/ -f2)
    container_ip_range=$(echo $container_ip | awk -F'.' '{print $1"."$2"."$3".0" }')
    container_ip_range="$container_ip_range/$container_cidr"
    write_step "Current container: Network"
    echo "IP address: $container_ip"
    echo "CIDR      : $container_ip_range"
}

# Entry point & Main processing
check_vector_current_container_k8s_secrets
check_vector_current_container_k8s_env
check_vector_current_container_app_env
check_vector_k8s_api
check_vector_vault_api
check_vector_network
