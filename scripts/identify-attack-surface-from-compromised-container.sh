#!/bin/bash
####################################################################
# Script to identify, the possible attack surface, when we are 
# in a compromised container deployed in a Kubernetes cluster
#
# References used:
#	https://github.com/righettod/toolbox-pentest-web/issues/44
#	https://kubernetes.io/docs/tasks/run-application/access-api-from-pod/
#	https://kubernetes.io/docs/concepts/configuration/secret/
#	https://github.com/righettod/toolbox-pentest-web/blob/master/docs/0_METHODOLOGIES.md#methodology-for-assumed-container-breach-assessment
#	https://docs.openshift.com/container-platform/4.16/rest_api/
#	https://developer.hashicorp.com/vault/docs/platform/k8s
#	https://developer.hashicorp.com/vault/api-docs
#	https://developer.hashicorp.com/vault/docs/secrets/kv
#	https://developer.hashicorp.com/vault/api-docs/system
#	https://unofficial-kubernetes.readthedocs.io/en/latest/concepts/policy/container-capabilities/
#	https://man7.org/linux/man-pages/man7/capabilities.7.html
#	https://kubernetes.io/docs/reference/kubectl/
#
# Requirements in terms of software:
# 	apt install curl libcap libcap2-bin nmap
# libcap       on Alpine
# libcap2-bin  on Debian
#
# Notes & conventions: 
#   K8S   === KUBERNETES
#   VAULT === HASHICORP VAULT
####################################################################

# Constants
NET_INTERFACE_NAME="eth0"
APP_COMMON_SECRETS_PATHS=("/etc/secrets" "/var/secrets")
KUBERNETES_SITE_BASE="https://cdn.dl.k8s.io"
KUBERNETES_SECRETS_PATH="/var/run/secrets/kubernetes.io"
KUBERNETES_SERVICE_ACCOUNT_TOKEN_FILE="$KUBERNETES_SECRETS_PATH/serviceaccount/token"
KUBERNETES_CURRENT_NAMESPACE_NAME_FILE="$KUBERNETES_SECRETS_PATH/serviceaccount/namespace"
KUBERNETES_API_DEFAULT_HOSTNAME="kubernetes.default.svc"
KUBERNETES_API_DEFAULT_HTTPS_PORT=443
KUBERNETES_INTERESTING_NS_SCOPED_API_LIST=("api/v1/namespaces/default/pods" "api/v1/namespaces/default/secrets" "api/v1/namespaces/default/configmaps" "api/v1/namespaces/default/endpoints" "api/v1/namespaces/default/services" "api/v1/namespaces/default/serviceaccounts")
KUBERNETES_INTERESTING_NOTNS_API_LIST=("api/v1/namespaces" "api/v1/nodes" "api/v1/persistentvolumes" "api/v1/pods" "api/v1/secrets" "version")
KUBERNETES_KUBECTL_INTERESTING_RESOURCE_TYPES=("configmaps" "deployments" "nodes" "persistentvolumes" "pods" "namespaces" "secrets" "serviceaccounts" "services" "roles")
VAULT_INTERESTING_API_LIST=("v1/sys/health" "v1/sys/host-info" "v1/sys/license/status" "v1/sys/auth" "v1/sys/config/state/sanitized" "v1/sys/internal/ui/mounts" "v1/sys/capabilities-self" "v1/sys/internal/ui/mounts/secret")

# Utility functions
function write_step(){
	echo -e "\e[93m[*] $1\e[0m"
}

function write_sub_step(){
	echo -e "\e[36m[>] $1\e[0m"
}

function write_step_failure(){
	echo -e "\e[91m[!] $1\e[0m"
}

# Processing functions
function test_k8s_api_access(){
    token=$1
    api_path=$2
    endpoint_type=$3
    endpoint="https://$KUBERNETES_SERVICE_HOST:$KUBERNETES_SERVICE_PORT_HTTPS/$api_path"    
    http_code=$(curl -ks -o /dev/null -w "%{http_code}" -H "Authorization: Bearer $token" "$endpoint")
    echo "($http_code) $endpoint_type: $api_path"
}


function test_vault_api_access(){
    token=$1
    api_path=$2
    endpoint_type=$3
    endpoint="$VAULT_ADDR/$api_path"
    http_code=$(curl -ks -o /dev/null -w "%{http_code}" -H "X-Vault-Token: $token" -H "X-Vault-Request: true" "$endpoint")
    echo "($http_code) $endpoint_type: $endpoint"
}


function check_vector_current_container_k8s_env(){
    write_step "Current container: Kubernetes environment"
    rc=1
    env_count=$(env | grep -Fc "KUBERNETES")
    if [ $env_count -ne 0 ]; then
        env | grep -F "KUBERNETES"
        rc=0
    else
        write_step_failure "Kubernetes environment variables not found."
        echo -n "Check if the default Kubernetes API HTTPS port on the default Kubernetes API hostname is open..."
        is_port_open=$(nmap -p 1,$KUBERNETES_API_DEFAULT_HTTPS_PORT --open -Pn $KUBERNETES_API_DEFAULT_HOSTNAME -oG - | grep -Fc " $KUBERNETES_API_DEFAULT_HTTPS_PORT/open/tcp/")
        if [ $is_port_open -ne 0 ]
        then
            echo "OPEN."
            echo "Set the corresponding value for Kubernetes environment variables."
            export KUBERNETES_SERVICE_HOST=$KUBERNETES_API_DEFAULT_HOSTNAME
            export KUBERNETES_SERVICE_PORT_HTTPS=$KUBERNETES_API_DEFAULT_HTTPS_PORT
			export KUBERNETES_SERVICE_PORT=$KUBERNETES_API_DEFAULT_HTTPS_PORT
            env | grep -F "KUBERNETES" | sort
            rc=0
        else
            echo "CLOSED/FILTERED."
            write_step_failure "Port is closed/filtered."
        fi
    fi
    return $rc
}


function check_vector_current_container_app_env(){
    write_step "Current container: App environment"
    expr="(SECRET|PASSWORD|PASS|PW|TOKEN|KEY|SALT)"
    rc=1
    env_count=$(env | grep -Eic "$expr")
    if [ $env_count -ne 0 ]; then
        env | grep -Ei "$expr"
        rc=0
    else
        write_step_failure "App environment variables related to secrets not found."
    fi
    return $rc
}


function check_vector_current_container_k8s_secrets(){
    write_step "Current container: Kubernetes secrets"
    rc=1
    if [ -d "$KUBERNETES_SECRETS_PATH" ]; then
        find "$KUBERNETES_SECRETS_PATH" -type f
        rc=0
    else
        write_step_failure "Kubernetes secrets folder not found."
    fi
    return $rc
}


function check_vector_current_container_app_secrets(){
    write_step "Current container: App secrets"
    rc=1
    for path in "${APP_COMMON_SECRETS_PATHS[@]}"
    do
        if [ -d "$path" ]; then
            file_count=$(find "$path" -type f | wc -l)
            if [ $file_count -ne 0 ]; then
                find "$path" -type f
                rc=0
            fi
        fi    
    done
    if [ $rc -ne 0 ]; then    
        write_step_failure "App common secrets folder not found or empty."
    fi
    return $rc
}


function check_vector_k8s_api_via_rest(){
    write_step "Kubernetes API access rights using service account token via calls to the REST API"
    rc=1
    if [ -f "$KUBERNETES_SERVICE_ACCOUNT_TOKEN_FILE" ]; then
        token=$(cat $KUBERNETES_SERVICE_ACCOUNT_TOKEN_FILE)
        current_namespace=$(cat $KUBERNETES_CURRENT_NAMESPACE_NAME_FILE)
        for api_path in "${KUBERNETES_INTERESTING_NOTNS_API_LIST[@]}"
        do
            test_k8s_api_access "$token" "$api_path" "General endpoint"
        done        
        for api_path in "${KUBERNETES_INTERESTING_NS_SCOPED_API_LIST[@]}"
        do
            test_k8s_api_access "$token" "$api_path" "Default namespace endpoint"
        done
        for api_path in "${KUBERNETES_INTERESTING_NS_SCOPED_API_LIST[@]}"
        do
            api_path_current_ns=$(echo "$api_path" | sed "s/default/$current_namespace/g")
            test_k8s_api_access "$token" "$api_path_current_ns" "Current namespace endpoint"
        done        
        rc=0        
    else
        write_step_failure "Kubernetes service account token file not found."
    fi
    return $rc
}


function check_vector_k8s_api_via_kubectl(){
    write_step "Kubernetes API access rights using service account token via calls with KUBECTL"
	rc=1
	kubectl version 1>/dev/null 2>&1
	if [ $? -ne 0 ]
	then
		write_step_failure "kubectl not found."
		return $rc
	fi
    if [ -f "$KUBERNETES_SERVICE_ACCOUNT_TOKEN_FILE" ]; then
		write_sub_step "Kubernetes version running on the client and server"
		kubectl version
		write_sub_step "List of API resources available"
		kubectl api-resources	
        for res_type in "${KUBERNETES_KUBECTL_INTERESTING_RESOURCE_TYPES[@]}"
        do
			write_sub_step "Check access to resource type '$res_type'"
            kubectl get $res_type -o wide
			kubectl get $res_type -n default -o wide
			kubectl get $res_type -n kube-system -o wide
        done              
        rc=0        
    else
        write_step_failure "Kubernetes service account token file not found."
    fi
    return $rc
}


function check_vector_vault_api(){
    write_step "Vault API access rights using vault token"
    token="$VAULT_TOKEN"
    rc=1
    if [ "$token" != "" ]; then
        for api_path in "${VAULT_INTERESTING_API_LIST[@]}"
        do
            test_vault_api_access "$token" "$api_path" "Endpoint"     
        done
        rc=0
    else
        write_step_failure "Vault token not found."    
    fi
    return $rc
}


function check_vector_network(){
    container_ip=$(ip addr show $NET_INTERFACE_NAME | grep "inet\b" | awk '{print $2}' | cut -d/ -f1)
    container_ip_range=$(echo $container_ip | awk -F'.' '{print $1"."$2"."$3".0" }')
    container_ip_range="$container_ip_range/24"
    write_step "Current container: Network"
    echo "IP address: $container_ip"
    echo "CIDR      : $container_ip_range"
}


function check_vector_current_container_capabilities(){
    write_step "Current container: Capabilities"
    rc=1    
    which capsh 1> /dev/null 2>&1
    if [ $? -eq 0 ]; then
        capsh --print
        rc=0
    else
        write_step_failure "Binary 'capsh' not found."     
    fi
    return $rc
}


function check_vector_current_container_internet_access(){
    write_step "Current container: Internet access"
    kubectl_version=$(curl --connect-timeout 10 --max-time 10 -sk $KUBERNETES_SITE_BASE/release/stable.txt)    
    can_access_k8s_site=$(echo "$kubectl_version" | grep -Ec "v[0-9.]+")
    if [ $can_access_k8s_site -eq 1 ]; then
        echo "Can access to the K8S site."
        echo "Use this URL to download the 'kubectl' binary: $KUBERNETES_SITE_BASE/release/$kubectl_version/bin/linux/amd64/kubectl"
    else
        write_step_failure "Cannot access to the K8S site."     
    fi
}


# Entry point & Main processing
check_vector_current_container_k8s_secrets
check_vector_current_container_app_secrets
check_vector_current_container_k8s_env
check_vector_current_container_app_env
check_vector_current_container_capabilities
check_vector_current_container_internet_access
check_vector_k8s_api_via_rest
check_vector_k8s_api_via_kubectl
check_vector_vault_api
check_vector_network

